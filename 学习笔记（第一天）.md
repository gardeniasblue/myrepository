# 学习笔记（第一天）

   ## 一、**continue:**



> **终止本次循环，直接跳到下一次循环**

``` java
int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

for (int i = 0; i < numbers.length; i++) {

if (i == 3) {

continue;

}

System.out.println("Count is: " + i);

}

```

> **在上述程序代码中，当条件 i==3 的时候执行 continue 语句，continue 语句会终止本次循环，循环体中 continue 之后的语句将不再执行，接着进行下次循环，所以输出结果中没有 3。程序运行结果如下：**

``` java
Count is: 0
Count is: 1
Count is: 2
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
```

## 二 、**运行vue项目** 

1、通过管理员权限进入到项目目录

2、执行命令npm install 

运行完成，会在项目目录下新建一个node_modules目录

3、执行命令npm run dev

运行完成

## 三、for循环

1、一般来说，java的for循环都是

``` java
 /* 建立一个数组 */
 int[] integers = {1， 2， 3， 4};
 /* 开始遍历 */
 for (int j = 0; j < integers.length; j++) {
     int i = integers[j];
     System.out.println(i);
 }
```

2、但在java1.5后，

```java
 /* 建立一个数组 */
 int[] integers = {1， 2， 3， 4};

 /* 开始遍历 */
 for (int i : integers) {
     System.out.println(i); /* 依次输出“1”、“2”、“3”、“4” */
 }

```

## 四 、继承和实现

### 1、继承(extends)

> 继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。Java继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用。比如可以先定义一个类叫车，车有以下属性：车体大小，颜色，方向盘，轮胎，而又由车这个类派生出轿车和卡车两个类，为轿车添加一个小后备箱，而为卡车添加一个大货箱。

> 特征：（1）继承关系是传递的。若类C继承类B，类B继承类A（多层继承），则类C既有从类B那里继承下来的属性与方法，也有从类A那里继承下来的属性与方法，还可以有自己新定义的属性和方法。继承来的属性和方法尽管是隐式的，但仍是类C的属性和方法。继承是在一些比较一般的类的基础上构造、建立和扩充新类的最有效的手段。
>
> （2）继承简化了人们对事物的认识和描述，能清晰体现相关类间的层次结构关系。
>
> （3）继承提供了[软件复用](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=584480&ss_c=ssc.citiao.link)功能。若类B继承类A，那么建立类B时只需要再描述与基类(类A)不同的少量特征(数据成员和成员方法)即可。这种做法能减小代码和数据的[冗余度](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7052378&ss_c=ssc.citiao.link)，大大增加程序的重用性。
>
> （4）继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性。
>
> （5）提供多重继承机制。从理论上说，一个类可以是多个一般类的特殊类，它可以从多个一般类中继承属性与方法，这便是多重继承。Java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承。

 ``` java
public class Test {
    public static void main(String[] args)  {
        new Circle();
    }
}
 
class Draw {
     
    public Draw(String type) {
        System.out.println(type+" draw constructor");
    }
}
 
class Shape {
    private Draw draw = new Draw("shape");
     
    public Shape(){
        System.out.println("shape constructor");
    }
}
 
class Circle extends Shape {
    private Draw draw = new Draw("circle");
    public Circle() {
        System.out.println("circle constructor");
    }
}
 ```

输出结果如下

``` java
shape draw constructor
shape constructor
circle draw constructor
circle constructor
```

结论：

> 　这道题目主要考察的是类继承时构造器的调用顺序和初始化顺序。要记住一点：父类的构造器调用以及初始化过程一定在子类的前面。由于Circle类的父类是Shape类，所以Shape类先进行初始化，然后再执行Shape类的构造器。接着才是对子类Circle进行初始化，最后执行Circle的构造器。



**注意**:super主要有两种用法：

``` java
　　1）super.成员变量/super.成员方法;

　　2）super(parameter1,parameter2....)

　　第一种用法主要用来在子类中调用父类的同名成员变量或者方法；第二种主要用在子类的构造器中显示地调用父类的构造器，要注意的是，如果是用在子类构造器中，则必须是子类构造器的第一个语句。
```

### 2、实现（implements）

> 关键字implements是一个类，实现一个接口用的关键字，它是用来实现接口中定义的抽象方法。实现一个接口，必须实现接口中的所有方法。使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔） 
> 还有几点需要注意： 
> (1)接口可以被多重实现（implements）,抽象类只能被单一继承（extends） 
> (2)接口只有定义,抽象类可以有定义和实现 
> (3)接口的字段定义默认为:public static final, 抽象类字段默认是”friendly”(本包可见)
>

**例子**

``` java
//定义Bread接口
public interface Bread{
  //定义一个方法吃面包(接口中没有具体的实现方法体)
  public void eatBread();
}

//Bread接口的实现类
public class BreadImpl implements Bread{
   //实现eatBread方法(接口的实现类中需要有具体的方法体)
   public void eatBread(){
     System.out.println("吃面包");
   }
}

```

**多重实现**

``` java
public class Man implements Bread,Milk{
  //实现了Bread接口中eatBread方法
  public void eatBread(){
     System.out.println("吃面包");
   }
//实现了Milk接口中drinkMilk方法
  public void drinkMilk(){
     System.out.println("喝牛奶");
   }
}
```

**总结**

> extends是继承类，implements是实现接口。 
> 类只能继承一个，接口可以实现多个。 
> extends继承父类的时候可以重写父类的方法，也可以调用父类的非私有方法；implements实现接口，必须实现接口的所有方法



